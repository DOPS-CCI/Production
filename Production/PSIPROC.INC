FUNCTION FORTRANIntegerFmt(spacing AS INTEGER, var AS INTEGER, fmt AS STRING) AS STRING
	LOCAL temp AS STRING

	temp = SPACE$(spacing + LEN(fmt))
	RSET temp = FORMAT$(var, fmt)

	FUNCTION = temp
END FUNCTION

FUNCTION FORTRANSingleFmt(spacing AS INTEGER, var AS SINGLE, fmt AS STRING) AS STRING
	LOCAL temp AS STRING

	temp = SPACE$(spacing + LEN(fmt) - 1)
	RSET temp = FORMAT$(var, "* " + fmt)

	FUNCTION = temp
END FUNCTION

FUNCTION FORTRANIntegerFmtLeft(spacing AS INTEGER, var AS INTEGER, fmt AS STRING) AS STRING
	LOCAL temp AS STRING

	temp = SPACE$(spacing + LEN(fmt))
	LSET temp = FORMAT$(var, fmt)

	FUNCTION = temp
END FUNCTION

FUNCTION FORTRANSingleFmtLeft(spacing AS INTEGER, var AS SINGLE, fmt AS STRING) AS STRING
	LOCAL temp AS STRING

	temp = SPACE$(spacing + LEN(fmt))
	LSET temp = FORMAT$(var, fmt)

	FUNCTION = temp
END FUNCTION

SUB STRNG(IVEC() AS INTEGER, L AS INTEGER, CM AS SINGLE, CH AS SINGLE, ORS AS SINGLE, EXPR AS SINGLE, VARR AS SINGLE, CR AS SINGLE)
	'COMPUTES WALD-WOLFOWITZ RUNS TEST. ASSUMES DATA REDUCED TO DICHOTOMOUS FORM (1/2)
	REDIM IVEC(L)
	DIM TYPES(2) AS SINGLE
	LOCAL AL AS SINGLE
	LOCAL DEV AS SINGLE
	LOCAL FACT AS SINGLE
	LOCAL I AS INTEGER

	CR = 1.0
	FOR I = 1 TO 2
		TYPES(I) = 0.0
	NEXT I

	TYPES(IVEC(1)) = 1.0

	FOR I = 2 TO L
		TYPES(IVEC(I)) = TYPES(IVEC(I)) + 1.0
		IF (IVEC(I) <> IVEC(I - 1)) THEN
			ORS = ORS + 1.0
		END IF
	NEXT I

	CM = TYPES(1)
	CH = TYPES(2)
	FACT = 2.0 * CH * CM
	AL = L
	EXPR = FACT / AL + 1
	VARR = FACT * (FACT - AL) / (AL^2 * (AL - 1))
	DEV = ORS - EXPR
	DEV = DEV - (0.5 * SGN(DEV))
	CR = DEV / SQR(VARR)

	'RETURN
END SUB

SUB STRNGN(NDATA() AS INTEGER, L AS INTEGER, OM AS SINGLE, OH AS SINGLE, ORS AS SINGLE, EXPR AS SINGLE, VARR AS SINGLE, CR AS SINGLE)
	DIM TYPES(2) AS SINGLE
	DIM IVEC(50) AS INTEGER
	LOCAL I AS INTEGER
	LOCAL K AS INTEGER
	LOCAL L1 AS INTEGER
	LOCAL FACT AS SINGLE
	LOCAL AL AS SINGLE
	LOCAL DEV AS SINGLE

	ORS = 1.0

	FOR I = 1 TO 2
		TYPES(I) = 0.0
	NEXT I

	K = 1
	FOR I = 1 TO L STEP 2
		IF (NDATA(I) - NDATA(I + 1) = 0) THEN
			IVEC(K) = 2
		ELSE
			IVEC(K) = 1
		END IF

		INCR K
	NEXT I

	L1 = L / 2

	TYPES(IVEC(1)) = 1.0

	FOR I = 2 TO L1
		TYPES(IVEC(I)) = TYPES(IVEC(I)) + 1.0
		IF (IVEC(I) <> IVEC(I - 1)) THEN
			ORS = ORS + 1.0
		END IF
	NEXT I

	OM = TYPES(1)
	OH = TYPES(2)

	FACT = 2.0 * OH * OM

	AL = L1

	EXPR = FACT/AL + 1.0

	VARR = FACT * (FACT - AL)/(AL^2 * (AL - 1))
	IF (VARR <= 0) THEN
		CR = 0.0
		RETURN
	END IF

	DEV = ORS - EXPR
	DEV = DEV - (0.5 * SGN(DEV))

	CR = DEV/SQR(VARR)
END SUB

SUB STRNG2(IVEC() AS INTEGER, L AS INTEGER, OM AS SINGLE, OH AS SINGLE, ORS AS SINGLE, EXPR AS SINGLE, VARR AS SINGLE, CR AS SINGLE, _
				ILO() AS INTEGER, EL() AS SINGLE, LMAX AS INTEGER, L1 AS INTEGER)
	REDIM IVEC(L)
	REDIM ILO(L1)
	REDIM EL(L1)
	DIM TYPES(2) AS SINGLE
	LOCAL I AS INTEGER
	LOCAL K AS INTEGER
	LOCAL NH AS INTEGER
	LOCAL NHT AS INTEGER
	LOCAL LF AS INTEGER
	LOCAL LIM AS INTEGER
	LOCAL AL AS SINGLE
	LOCAL FAC AS SINGLE
	LOCAL FAC2 AS SINGLE
	LOCAL FACT AS SINGLE
	LOCAL DEV AS SINGLE

	ORS = 1.0

	FOR I = 1 TO 2
		TYPES(I) = 0.0
	NEXT I

	TYPES(IVEC(1)) = 1.0

	FOR I = 2 TO L
		TYPES(IVEC(I)) = TYPES(IVEC(I)) + 1.0
		IF (IVEC(I) <> IVEC(I - 1)) THEN
			ORS = ORS + 1.0
		END IF
	NEXT I

	OM = TYPES(1)
	OH = TYPES(2)
	FACT = 2.0 * OH * OM
	AL = L
	EXPR = FACT/AL + 1.0
	VARR = FACT * (FACT - AL)/(AL * AL * (AL - 1.0))

	'PATCH FOR DEGENERATE CASE WITH ONLY 1 TYPE OF EVENT

	IF (VARR <= 0) THEN
		CR = 0.0
		FOR I = 1 TO L
			ILO(I) = 0
			EL(I) = 0.0
		NEXT I
		IF (OH > 0) THEN
			EL(L) = 1.0
			ILO(L)= 1
		END IF

		RETURN
	END IF

	DEV = ORS - EXPR
	DEV = DEV - (0.5 * SGN(DEV))
	CR = DEV / SQR(VARR)

	'STRING-LENGTH DATA; FIRST CALCULATE EXPECTATIONS UP TO CH

	FAC = OM * (OM + 1.0)
	NH = OH
	LIM = MIN(NH,L1)
	FAC2 = OH

	' FIRST ZERO EL ARRAY OUT TO LIMIT

	FOR K = 1 TO LIM
		EL(K) = 0.0
	NEXT K

	EL(1) = FAC * FAC2 / (AL * (AL - 1.0))

	IF (OH - 1.0 > 0) THEN
		FOR K = 2 TO LIM
			FAC2 = FAC2 - 1.0
			EL(K) = EL(K - 1) * (FAC2 / (AL - (K * 1.0)))
			' TRUNCATE COMPUTATION OF EXPECTATIONS FOR BIG SERIES
			IF (EL(K) - 0.00001 <= 0) THEN
				EXIT FOR
			END IF
		NEXT K
	END IF

	FOR I = 1 TO NH
		ILO(I) = 0
	NEXT I

	NHT = 0
	I = 0
	LF = 0

	DO
		I = I + 1

		IF (IVEC(I) - 1 <= 0) THEN
			IF (LF > 0) THEN
				LF = 0
				ILO(K) = ILO(K) + 1
				' IF ALL HITS ACCOUNTED FOR - EXIT
				NHT = NHT + K
				IF (NH - NHT <= 0) THEN
					 FOR K = 1 TO LIM
						IF (ILO(K) > 0) THEN
							LMAX = K
						END IF
					 NEXT K

					 RETURN
				 END IF
			ELSE
				K = K + 1
			END IF
		ELSE
			IF (LF <= 0) THEN
				LF = 1
				K = 1
			END IF
		END IF

		IF (I - L >= 0) THEN
			IF (LF = 1) THEN
				ILO(K) = ILO(K) + 1
			END IF
		ELSE
			ITERATE DO
		END IF

	LOOP

END SUB

SUB ZSCOR(X AS SINGLE, AN AS SINGLE, NT AS INTEGER, EXP1 AS SINGLE, VAR AS SINGLE, CR AS SINGLE)
	LOCAL DEV AS SINGLE
	LOCAL P AS SINGLE

	IF (NT > 0) THEN
		P = 1.0/(NT * 1.0)
		EXP1 = AN * P
		VAR = EXP1 * (1.0 - P)
	END IF

	DEV = X - EXP1
	DEV = DEV - (0.5 * SGN(DEV))
	CR = DEV/SQR(VAR)
END SUB

SUB STVNS(C() AS SINGLE, T() AS SINGLE, NT AS INTEGER, NTR AS INTEGER, EXP1 AS SINGLE, VAR AS SINGLE)
	'REDIM C(NT)
	'REDIM T(NT)
	LOCAL I AS INTEGER
	LOCAL AN AS SINGLE
	LOCAL S1 AS SINGLE
	LOCAL S2 AS SINGLE
	LOCAL S3 AS SINGLE
	LOCAL S4 AS SINGLE

	AN = NTR
	S1 = 0.0
	S2 = 0.0

	FOR I = 1 TO NT
		S3 = C(I) * T(I)
		S4 = S3 * (C(I) + T(I))
		S1 = S1 + S3
		S2 = S2 + S4
	NEXT I

	EXP1 = S1/AN
	VAR = (S1 * S1 - AN * S2 + AN * AN * S1) / (AN * AN * (AN - 1.0))

END SUB

SUB RUNDIS(NT AS INTEGER, N1 AS INTEGER, NR AS INTEGER, RSCOR() AS SINGLE)
	REDIM RSCOR(N1)
	DIM IOX AS GLOBAL INTEGER
	DIM PVAL(51) AS SINGLE
	LOCAL NTR AS INTEGER
	LOCAL P AS SINGLE
	LOCAL AN AS SINGLE
	LOCAL SOBS AS SINGLE
	LOCAL CUMP AS SINGLE
	LOCAL DMAX AS SINGLE
	LOCAL CFREQ AS SINGLE
	LOCAL DEV AS SINGLE
	LOCAL EXP1 AS SINGLE
	LOCAL I AS INTEGER
	LOCAL ISCOR AS INTEGER

	NTR = N1 - 1
	P = 1.0 / (NT * 1.0)
	'CALL RSCORP(NTR, P, PVAL)

	PRINT #IOX, "ANALYSIS OF RUN-SCORE DISTRIBUTION"
	PRINT #IOX, SPC(5); "SCORE"; SPC(5); "NOBS"; SPC(5); "NEXP"; SPC(5); "CUM FREQ"; SPC(5); "PVAL"; SPC(6); "CUMP"; SPC(6); "/DEV/"

	AN = NR
	SOBS = 0.0
	CUMP = 0.0
	DMAX = 0.0

	FOR I = 1 TO N1
		ISCOR = I - 1
		CUMP = CUMP + PVAL(I)
		SOBS = SOBS + RSCOR(I)
		CFREQ = SOBS / AN
		DEV = ABS(CFREQ - CUMP)
		EXP1 = AN * PVAL(I)
		PRINT #IOX, SPC(7);FORMAT$(ISCOR, "000");SPC(4);FORMAT$(RSCOR(I), "00000.0");SPC(2);FORMAT$(EXP1, "00000.00"); _
					SPC(7);FORMAT$(CFREQ, "00.0000");SPC(4);FORMAT$(PVAL(I), "00.0000");SPC(4);FORMAT$(CUMP, "00.0000"); _
					SPC(4);FORMAT$(DEV, "00.0000")

		IF (DEV - DMAX > 0) THEN
			DMAX = DEV
		END IF
	NEXT I

	PRINT #IOX, " FOR KOLMOGROV-SMIRNOV GOODNESS-OF-FIT TEST, D=";FORMAT$(DMAX, "00.0000")
END SUB

SUB RSCORP(N AS INTEGER, P AS SINGLE, PVAL() AS SINGLE)
	REDIM PVAL(1)
	LOCAL FACN AS DOUBLE
	LOCAL FACN1 AS DOUBLE
	LOCAL FACN2 AS DOUBLE
	LOCAL P1 AS DOUBLE
	LOCAL Q1 AS DOUBLE
	LOCAL Q AS SINGLE
	LOCAL FN AS SINGLE
	LOCAL FN1 AS SINGLE
	LOCAL FN2 AS SINGLE
	LOCAL I AS INTEGER
	LOCAL N1 AS INTEGER
	LOCAL K AS INTEGER

	Q = 1.0 - P
	FACN = 1.0
	FN = 1.0
	Q1 = Q

	FOR I = 2 TO N
		FACN = FACN * (I * 1.0)
		Q1 = Q1 * Q
	NEXT I

	PVAL(1) = Q1
	FN1 = N + 1
	FACN1 = FACN
	FN2 = 0.0
	FACN2 = 1.0
	P1 = 1.0
	N1 = N + 1

	FOR K = 2 TO N1
		P1 = P1 * P
		Q1 = Q1 / Q
		FN1 = FN1 -  1.0
		FN2 = FN2 + 1.0
		FACN2 = FACN2 * FN2
		FACN1 = FACN1 / FN1
		PVAL(K) = (FACN / (FACN1 * FACN2)) * P1 * Q1
	NEXT K

END SUB

SUB CMCOMP(NT AS INTEGER, K AS INTEGER, CRIT AS SINGLE)
	   DIM IOX AS GLOBAL INTEGER
	   DIM ITI AS GLOBAL INTEGER
	   DIM CMAT(14,14,3) AS GLOBAL SINGLE
	   DIM WORK(14,14) AS SINGLE
	   DIM STATS(14,14) AS SINGLE
	   DIM DIAG(14,2) AS SINGLE
	   LOCAL I AS INTEGER
	   LOCAL J AS INTEGER
	   LOCAL NT1 AS INTEGER
	   LOCAL IFLAG AS INTEGER
	   LOCAL EXP1 AS SINGLE
	   LOCAL DII AS SINGLE
	   LOCAL CMCHI AS SINGLE
	   LOCAL CHISQ AS SINGLE
	   DIM DF AS SINGLE

	   NT1 = NT + 1

	   FOR I = 1 TO NT1
		   FOR J = 1 TO NT1
			   WORK(I,J) = CMAT(I,J,K)
		   NEXT J
	   NEXT I

	   'DELETE DIAGONALS FROM ROW & COLUMN SUMS, INITIALIZE DIAGS TO 1.0
	   FOR I = 1 TO NT
		   WORK(NT1,I) = WORK(NT1,I) - WORK(I,I) + 1.0
		   WORK(I,NT1) = WORK(I,NT1) - WORK(I,I) + 1.0
		   WORK(NT1,NT1) = WORK(NT1,NT1) - WORK(I,I) + 1.0
		   CMAT(NT1,I,K) = CMAT(NT1,I,K) - WORK(I,I)
		   CMAT(I,NT1,K) = CMAT(I,NT1,K) - WORK(I,I)
		   CMAT(NT1,NT1,K) = CMAT(NT1,NT1,K) - WORK(I,I)
		   WORK(I,I) = 1.0
	   NEXT I

	   'ITERATION CODE
	   DO
		   IFLAG = 0
		   FOR I = 1 TO NT
			   EXP1 = WORK(I, NT1) * WORK(NT1, I) / WORK(NT1,NT1)

			   'HEDGE FOR POSSIBLE ZERO EXPECTATION AT START
			   IF (EXP1 <= 0) THEN
				   EXP1 = 2.0
			   ELSE
				   DII = EXP1 - WORK(I,I)
			   END IF

			   IF (DII / WORK(I,I) > CRIT) THEN
				   IFLAG = 1
			   END IF

			   WORK(I,I) = EXP1
			   WORK(NT1,I) = WORK(NT1,I) + DII
			   WORK(I,NT1) = WORK(I,NT1) + DII
			   WORK(NT1,NT1) = WORK(NT1,NT1) + DII
		   NEXT I

		   IF (IFLAG <= 0) THEN
			   'ITERATION COMPLETE, GET STATISTICS
			   CMCHI = 0.0
		   ELSE
				ITERATE DO
		   END IF
	   LOOP

	   FOR I = 1 TO NT
		   DIAG(I,I) = WORK(I,I)
	   NEXT I

	   FOR I = 1 TO NT
		   FOR J = 1 TO NT
			   EXP1 = WORK(I,NT1) * WORK(NT1,J) / WORK(NT1,NT1)
			   CHISQ = (WORK(I,J) - EXP1)^2 / EXP1
			   CMCHI = CMCHI + CHISQ
			   STATS(I,J) = CHISQ
			   WORK(I,J) = EXP1
		   NEXT J
	   NEXT I

	   'STASH RECOMPUTE DIAGONAL AND ZERO MATRIX DIAGONALS
	   FOR I = 1 TO NT
		   DIAG(I,2) = WORK(I,I)
		   WORK(I,I) = 0.0
		   CMAT(I,I,K) = 0.0
	   NEXT I

	   'DELETE NEUTRAL DIAGONALS FROM ARRAY MARGINALS
	   FOR I = 1 TO NT
		   WORK(NT1,I) = WORK(NT1,I) - DIAG(I,1)
		   WORK(I,NT1) = WORK(I,NT1) - DIAG(I,1)
		   WORK(NT1,NT1) = WORK(NT1,NT1) - DIAG(I,1)
	   NEXT I

	   'NOW WRITE THE BUGGERS PLUS STATS
	   DF = (NT - 1) * (NT - 1) - NT

	   PRINT " CONSISTENT MISSING ANALYSIS"
	   PRINT " CELL ELEMENTS ARE O, E, & CHISQUARE"
	   FOR I = 1 TO NT
		   PRINT #IOX, FORMAT$(I, "00");
		   FOR J = 1 TO NT1
			   PRINT #IOX, FORMAT$(CMAT(I,J,K), "000000.");
		   NEXT J
		   PRINT #IOX,

		   PRINT #IOX, SPC(3);
		   FOR J = 1 TO NT1
			   PRINT #IOX, FORMAT$(WORK(I,J), "000000.0");
		   NEXT J
		   PRINT #IOX,

		   PRINT #IOX, SPC(3);
		   FOR J = 1 TO NT
			   PRINT #IOX, FORMAT$(STATS(I,J), "0000.00");
		   NEXT J
		   PRINT #IOX,

'           PRINT #IOX, SPC(3);
'           PRINT #IOX, FORMAT$(I, "00");
'           FOR J = 1 TO NT1
'               PRINT #IOX, FORMAT$(CMAT(I,J,K), "000000.");
'           NEXT J
'           PRINT #IOX,
'
'           PRINT #IOX, SPC(3);
'           FOR J = 1 TO NT1
'               PRINT #IOX, FORMAT$(WORK(I,J), "000000.0");
'           NEXT J
'           PRINT #IOX,
	   NEXT I

	   'WRITE DIAGONALS
	   PRINT #IOX, " NEUTRALIZED AND RECOMPUTED DIAGONALS"
	   PRINT #IOX, SPC(1);
	   FOR I = 1 TO NT
		   PRINT #IOX, FORMAT$(DIAG(I,1), "0000.00");
	   NEXT I
	   PRINT #IOX,

	   PRINT #IOX, SPC(1);
	   FOR I = 1 TO NT
		   PRINT #IOX, FORMAT$(DIAG(I,2), "0000.00");
	   NEXT I
	   PRINT #IOX,

	   PRINT #IOX, " CONSISTENT MISSING CHISQUARE=";
	   PRINT #IOX, FORMAT$(CMCHI, "000000.00");" WITH ";FORMAT$(DF, "00000.");" DF"

END SUB

SUB CONFU(NT AS INTEGER, K AS INTEGER)
	DIM IOX AS GLOBAL INTEGER
	DIM ITI AS GLOBAL INTEGER
	DIM CMAT(14,14,3) AS GLOBAL SINGLE
	DIM IHDR(14) AS GLOBAL ASCIIZ*2
	DIM RESP(12) AS SINGLE
	DIM TARGS(12) AS SINGLE
	DIM LBL(3) AS ASCIIZ*2
	LOCAL NT1 AS INTEGER
	LOCAL NT2 AS INTEGER
	LOCAL I AS INTEGER
	LOCAL J AS INTEGER
	LOCAL CHISQ AS SINGLE
	LOCAL DEV AS SINGLE
	LOCAL EXP1 AS SINGLE
	LOCAL SUM AS SINGLE
	LOCAL HITS AS SINGLE
	LOCAL DF AS SINGLE
	LOCAL VAR AS SINGLE
	LOCAL CR AS SINGLE


	LBL(1) = " 0" : LBL(2) = "-1" : LBL(3) = "+1"

	NT1 = NT + 1
	NT2 = NT + 2

	'FIRST GET MARGINALS AND HIT PERCENTS
	FOR J = 1 TO NT
		FOR I = 1 TO NT
			CMAT(NT1,J,K) = CMAT(NT1,J,K) + CMAT(I,J,K)
		NEXT I
	NEXT J

	FOR I = 1 TO NT1
		FOR J = 1 TO NT
			CMAT(I,NT1,K) = CMAT(I,NT1,K) + CMAT(I,J,K)
		NEXT J
	NEXT I

	FOR I = 1 TO NT1
		CMAT(I,NT2,K) = (CMAT(I,I,K)/CMAT(I,NT1,K)) * 100.0
	NEXT I

	'NOW GET CHISQUARE FOR TABLE
	CHISQ = 0.0
	FOR I = 1 TO NT
		FOR J = 1 TO NT
			EXP1 = CMAT(I,NT1,K) * CMAT(NT1,J,K) / CMAT(NT1,NT1,K)
			DEV = CMAT(I,J,K) - EXP1
			IF (NT = 2) THEN
				DEV = DEV - (0.5 * SGN(DEV))
			END IF
			CHISQ = CHISQ + DEV * DEV / EXP1
			DF = (NT - 1) * (NT - 1)
		NEXT J
	NEXT I

	'PLUS CR'S FOR EXACT HITS
	SUM = CMAT(NT1,NT1,K)

	HITS = 0.0

	FOR I = 1 TO NT
		RESP(I) = CMAT(I,NT1,K)
		TARGS(I) = CMAT(NT1,I,K)
		HITS = HITS + CMAT(I,I,K)
	NEXT I

	CALL ZSCOR(HITS, SUM, NT, EXP1, VAR, CR)

	PRINT #IOX, "RAN CONFUSION MATRIX FOR ";LBL(K);" TARGETS"

	PRINT #IOX, SPC(2);
	FOR I = 1 TO NT2
		PRINT #IOX, SPC(4);IHDR(I);
	NEXT I
	PRINT #IOX,


	FOR I = 1 TO NT
		PRINT #IOX, IHDR(I);
		FOR J = 1 TO NT2
			PRINT #IOX, FORMAT$(CMAT(I,J,K), "000000.");
		NEXT J
		PRINT #IOX,
	NEXT I
	PRINT #IOX,

	PRINT #IOX, "  T";
	FOR J = 1 TO NT2
		PRINT #IOX, FORMAT$(CMAT(NT1,J,K), "000000.");
	NEXT J
	PRINT #IOX,

	PRINT #IOX, " SUMMARY STATISTICS FOR TABLE: CHISQUARE=";FORMAT$(CHISQ, "000000.00");" WITH ";FORMAT$(DF, "00000.")
	PRINT #IOX, " BINOMIAL CR BASED ON ";FORMAT$(HITS, "00000.");" HITS IN ";FORMAT$(SUM, "000000.");" TRIALS=";FORMAT$(CR, "0000.00"); _
				" MCE=";FORMAT$(EXP1, "000000.00");", VARIANCE=";FORMAT$(VAR, "000000.00")

	CALL STVNS(RESP(), TARGS(), NT, INT(SUM), EXP1, VAR)

	CALL ZSCOR(HITS, 0, 0, EXP1, VAR, CR)

	PRINT #IOX, " OVERALL STEVENS RESULT- MCE=";FORMAT$(EXP1, "000000.00");" VARIANCE=";FORMAT$(VAR, "000000.00");", CR=";FORMAT$(CR, "0000.00")

END SUB

FUNCTION NQUINT(N AS INTEGER) AS INTEGER
	LOCAL L AS INTEGER
	LOCAL TEMP AS INTEGER

	TEMP = 0
	L = N
	DO
		IF (L MOD 5 = 0) THEN
			TEMP = L / 5
			EXIT DO
		ELSE
			L = L + 1
		END IF
	LOOP

	FUNCTION = TEMP
END FUNCTION
